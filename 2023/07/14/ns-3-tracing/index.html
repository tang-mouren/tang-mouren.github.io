<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ns-3 tracing | Tang-mouren's Blog</title><meta name="author" content="Tang"><meta name="copyright" content="Tang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NS-3 Tracing (草稿)[TOC] 前言概述ns-3 tracing system(跟踪系统)可以让使用者在无需对源代码进行重新编译的前提下进行自定义化的程序输出从而对仿真程序的运行状态进行追踪检测。 ns-3 tracing system分为两个部分，一个是跟踪源(trace sources)，一个是追踪接收器(trace sinks)，而ns-3提供了连接两者的函数。如下所示： 12">
<meta property="og:type" content="article">
<meta property="og:title" content="ns-3 tracing">
<meta property="og:url" content="https://tang-mouren.github.io/2023/07/14/ns-3-tracing/index.html">
<meta property="og:site_name" content="Tang-mouren&#39;s Blog">
<meta property="og:description" content="NS-3 Tracing (草稿)[TOC] 前言概述ns-3 tracing system(跟踪系统)可以让使用者在无需对源代码进行重新编译的前提下进行自定义化的程序输出从而对仿真程序的运行状态进行追踪检测。 ns-3 tracing system分为两个部分，一个是跟踪源(trace sources)，一个是追踪接收器(trace sinks)，而ns-3提供了连接两者的函数。如下所示： 12">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tang-mouren.github.io/Battlefieldjpg/shocktrooper.jpg">
<meta property="article:published_time" content="2023-07-14T07:06:25.000Z">
<meta property="article:modified_time" content="2023-07-14T07:07:21.162Z">
<meta property="article:author" content="Tang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tang-mouren.github.io/Battlefieldjpg/shocktrooper.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tang-mouren.github.io/2023/07/14/ns-3-tracing/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ns-3 tracing',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-14 15:07:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/Battlefieldjpg/shocktrooper.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Tang-mouren's Blog"><span class="site-name">Tang-mouren's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ns-3 tracing</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-07-14T07:06:25.000Z" title="Created 2023-07-14 15:06:25">2023-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-07-14T07:07:21.162Z" title="Updated 2023-07-14 15:07:21">2023-07-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ns-3 tracing"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="NS-3-Tracing-草稿"><a href="#NS-3-Tracing-草稿" class="headerlink" title="NS-3 Tracing (草稿)"></a>NS-3 Tracing (草稿)</h2><p>[TOC]</p>
<h3 id="前言概述"><a href="#前言概述" class="headerlink" title="前言概述"></a>前言概述</h3><p>ns-3 tracing system(跟踪系统)可以让使用者在无需对源代码进行重新编译的前提下进行自定义化的程序输出从而对仿真程序的运行状态进行追踪检测。</p>
<p>ns-3 tracing system分为两个部分，一个是跟踪源(trace sources)，一个是追踪接收器(trace sinks)，而ns-3提供了连接两者的函数。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::ostringstream oss;</span><br><span class="line">  oss &lt;&lt;<span class="string">&quot;/NodeList/&quot;</span> &lt;&lt; wifiStaNodes.<span class="built_in">Get</span> (nWifi - <span class="number">1</span>)-&gt;<span class="built_in">GetId</span> () &lt;&lt;<span class="string">&quot;/$ns3::MobilityModel/CourseChange&quot;</span>;</span><br><span class="line">  Config::<span class="built_in">ConnectWithoutContext</span> (oss.<span class="built_in">str</span> (), <span class="built_in">MakeCallback</span> (&amp;CourseChange));<span class="comment">// The connection function.</span></span><br><span class="line"><span class="comment">//The function CourseChange will be called when the tracing source changes.</span></span><br></pre></td></tr></table></figure>

<p>ns-3往往使用Config子系统来实现追踪。追踪系统使用config path来选择追踪源。</p>
<p>比如说，对于一个nodelist中id为7的node，想要追踪，path可能是如下这一行：”&#x2F;NodeList&#x2F;7&#x2F;$ns3::MobilityModel&#x2F;CourseChange”。其中，config path的最后的段必须是<strong>对象的属性</strong>！</p>
<p>Config::ConnectWithoutContext和Config::Connext实际上寻找一个Ptr&lt;Object&gt;的一个封装指针，然后再最底层次上调用合适的TraceConnect方法函数。</p>
<p>“&#x2F;“字符指代一个伪命名域。”&#x2F;NodeList&#x2F;7”指向了Nodecontainer中的一个明确的node，表现形式为Ptr&lt;Node&gt;，它同时也是ns3::Object的子类。接下来的路径段由”$”字符打头。”$”表明申请另一个已经聚合的对象。注意，ns3中支持面向对象中的类聚合设计思路，从而形成不同对象之间的关联。比如说上面例子中的“$ns3::MobilityModel”，就表明了调用node-&gt;GetObject&lt;MobilityModel&gt;()。GetObject&lt;class T&gt;很巧妙的实现了类型的转换，返回一个Ptr&lt;class T&gt;的指针。而MobilityModel有一个mCourseChange的属性。</p>
<p>在mobility-model.cc中可以看到有如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">AddTraceSource</span> (<span class="string">&quot;CourseChange&quot;</span>, <span class="string">&quot;The value of the position and/or velocity vector changed&quot;</span>, <span class="built_in">MakeTraceSourceAccessor</span> (&amp;MobilityModel::m_courseChangeTrace))</span><br></pre></td></tr></table></figure>

<p>在mobility-model.h中可以看到如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Used to alert subscibers that a change in direction, velocity, or position has occurred.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  TracedCallback&lt;Ptr&lt;<span class="type">const</span> MobilityModel&gt; &gt; m_courseChangeTrace;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Must be invoked by subclasses when the course of the</span></span><br><span class="line"><span class="comment">   * position changes to notify course change listeners.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NotifyCourseChange</span> <span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">MobilityModel::NotifyCourseChange</span> <span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">m_courseChangeTrace</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//It can be seen that the NotifyCourseChange function calls the </span></span><br><span class="line"><span class="comment">//attribute function pointer m_courseChangeTrace</span></span><br></pre></td></tr></table></figure>

<p>可见，当course发生更改的时候，会有一个NotifyCoursechange的函数调用，在MobilityModel base class层面上进行调用。之后，会调用m_courseChangeTrace，调用任意注册的追踪接收器。</p>
<p>这里，m_courseChangeTrace就是一个特殊的callbacks的列表，当使用Config functions的时候可以被用于连接查询。**调用m_courseChangeTrace就会调用所有注册的callback function(目前理解是这样，存疑)**。</p>
<p>话说到这里，那么MobilityModel class具体是一个什么样的类呢》它被设计为一个base class来给具体的子类提供一个普适化的接口。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://rainsia.github.io/2018/06/04/ns3-007/">NS-3学习笔记（七）：NS-3的对象框架 之 聚合 | Rain’s Blog (rainsia.github.io)</a>NS-3中框架的聚合可以参考这篇文章。</p>
</blockquote>
<ol>
<li>调试的核心在于必须有回调的源，但是如何找到可用的回调源？</li>
<li>找到了源，如何找出config path？</li>
<li>如何确定callback function的类型？</li>
<li>搞定了上述的一切，这究竟是什么？</li>
</ol>
<h3 id="有哪些可用的跟踪源？"><a href="#有哪些可用的跟踪源？" class="headerlink" title="有哪些可用的跟踪源？"></a>有哪些可用的跟踪源？</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nsnam.org/docs/release/3.39/doxygen/de/de5/_trace_source_list.html">ns-3: All TraceSources (nsnam.org)</a>可以查看。</p>
</blockquote>
<h3 id="如何确定config-path？"><a href="#如何确定config-path？" class="headerlink" title="如何确定config path？"></a>如何确定config path？</h3><p>首先，在上面这个网址中，点开具体的class后可以在界面中搜索到Detailed Description.一个例子如下，有三个重要的内容，config paths, attributes, tracesources.</p>
<img src="C:\Users\tang\AppData\Roaming\Typora\typora-user-images\image-20230709144902486.png" alt="image-20230709144902486" style="zoom: 50%;" />

<p>一种方式可以找出有人已经确认的ns-3 codebase</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name ’*.cc’ | xargs grep CourseChange | grep Connect</span><br></pre></td></tr></table></figure>

<p>有了这个路径之后，就可以使用调用Config subsystem中的Config::Connect, Config::Set函数。其中，Config::Connect会匹配与路径相符合的跟踪源，将输入回调和它们进行连接，同时callback函数在被调用的时候会额外接收一个基于跟踪时间通知的上下文字符串。如果不想接收额外的字符串则可以使用ConnectWithoutContext。此外，Config::Connect失败会产生致命错误。如果在失败的时候产生致命的错误，则可以使用ConnectFailSafe函数。</p>
<p>callback will receive an extra context string upon trace event notification.</p>
<p>For example, in this case,<br>src&#x2F;mobility&#x2F;examples&#x2F;main-random-topology.cchas something just waiting for you to use:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Config::<span class="built_in">Connect</span> (<span class="string">&quot;/NodeList/*/$ns3::MobilityModel/CourseChange&quot;</span>,</span><br><span class="line"><span class="built_in">MakeCallback</span> (&amp;CourseChangeCallback));</span><br></pre></td></tr></table></figure>

<h3 id="如何找出回调函数的返回值以及参数类型？"><a href="#如何找出回调函数的返回值以及参数类型？" class="headerlink" title="如何找出回调函数的返回值以及参数类型？"></a>如何找出回调函数的返回值以及参数类型？</h3><p>最简单的方式就是在之前提到Detailed information中的TraceSources。</p>
<img src="C:\Users\tang\AppData\Roaming\Typora\typora-user-images\image-20230709210145967.png" alt="image-20230709210145967" style="zoom: 50%;" />

<p>先找到上面的source名称。Config Path + 名称就是完整的trace path。所以就有了最上面例子中这样一段使用ostringstream的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::ostringstream oss;</span><br><span class="line">  oss &lt;&lt;<span class="string">&quot;/NodeList/&quot;</span> &lt;&lt; wifiStaNodes.<span class="built_in">Get</span> (nWifi - <span class="number">1</span>)-&gt;<span class="built_in">GetId</span> () &lt;&lt;<span class="string">&quot;/$ns3::MobilityModel/CourseChange&quot;</span>;</span><br><span class="line">  Config::<span class="built_in">ConnectWithoutContext</span> (oss.<span class="built_in">str</span> (), <span class="built_in">MakeCallback</span> (&amp;CourseChange));<span class="comment">// The connection function.</span></span><br><span class="line"><span class="comment">//The function CourseChange will be called when the tracing source changes.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再找到callback signature，它展示了callback function应有的形式。其中callback function的返回值其实必定都是void。</p>
<p>找到回调函数应有的类型之后，就可以自己创建回调函数并且使用Config::Connect函数来进行关联，然后查看追踪信息了。当然也可以采用config::ConnectwithoutText函数。这两个连接形式要使用不同格式的callback function。Connect 的Path string的生成可以考虑使用 std::ostringstream来进行装载。<strong>其中Connect函数的形式可以把trace path传入callback function中，这样在打印追踪信息的时候可以更加明确是哪一个追踪源的信息。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">CourseChange</span><span class="params">(Ptr&lt;<span class="type">const</span> MobilityModel&gt; model)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="comment">// for Config::ConnectiwithoutText</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">CourseChange</span><span class="params">(std::string context, Ptr&lt;<span class="type">const</span> MobilityModel&gt; model)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="comment">// for Config::Connect</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TraceValue又是什么？"><a href="#TraceValue又是什么？" class="headerlink" title="TraceValue又是什么？"></a>TraceValue又是什么？</h3><p>参考src&#x2F;core&#x2F;model&#x2F;traced-value.h(注：此处参考的教程为ns-3.18，不同版本的路径可能不一样)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TracedValue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span> <span class="params">(<span class="type">const</span> T &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_v != v)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="built_in">m_cb</span> (m_v, v);</span><br><span class="line">            m_v = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T m_v;</span><br><span class="line">        TracedCallback&lt;T,T&gt; m_cb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见，TracedValue是一个模板类的封装。而TracedCallback&lt;T, T&gt;中的T于此有所关联。上面的那个总结的例子中，IntTrace(int32_t, int32_t)，正是对这个TracedCallback的实例化。</p>
<h3 id="一个例子进行回顾"><a href="#一个例子进行回顾" class="headerlink" title="一个例子进行回顾"></a>一个例子进行回顾</h3><p>下面是ns-3 tutorial fourth.cc的代码。它没有直接利用Config system，而是对自己的object手动添加了trace source path，并且利用trace connect对添加的trace source path添加了回调函数。这一个例子可以对上文的所有内容进行一个梳理回顾。下面代码这种低层次的实现方式显得繁琐，这也就告知了为什么ns-3需要一个Config subsytem对庞大的trace source进行一个科学的管理，方便编程者实现对程序内部各种信息的追踪。</p>
<p>tutorial原话： The internal code for Config::ConnectWithoutContext and Config::Connect actually do find a Ptr and call the appropriate TraceConnect method at the lowest level.具体寻找和解析的过程在上文中的Path路径的解析已经有所提及</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"> * it under the terms of the GNU General Public License version 2 as</span></span><br><span class="line"><span class="comment"> * published by the Free Software Foundation;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment"> * GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment"> * along with this program; if not, write to the Free Software</span></span><br><span class="line"><span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/uinteger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/traced-value.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/trace-source-accessor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ns3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> : <span class="keyword">public</span> Object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> TypeId <span class="title">GetTypeId</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">static</span> TypeId tid = <span class="built_in">TypeId</span> (<span class="string">&quot;MyObject&quot;</span>)</span><br><span class="line">      .<span class="built_in">SetParent</span> (Object::<span class="built_in">GetTypeId</span> ())</span><br><span class="line">      .<span class="built_in">AddConstructor</span>&lt;MyObject&gt; ()</span><br><span class="line">      .<span class="built_in">AddTraceSource</span> (<span class="string">&quot;MyInteger&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;An integer value to trace.&quot;</span>,</span><br><span class="line">                       <span class="built_in">MakeTraceSourceAccessor</span> (&amp;MyObject::m_myInt))</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> tid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MyObject</span> () &#123;&#125;</span><br><span class="line">  TracedValue&lt;<span class="type">int32_t</span>&gt; m_myInt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">IntTrace</span> <span class="params">(<span class="type">int32_t</span> oldValue, <span class="type">int32_t</span> newValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Traced1231 &quot;</span> &lt;&lt; oldValue &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; newValue &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Ptr&lt;MyObject&gt; myObject = <span class="built_in">CreateObject</span>&lt;MyObject&gt; ();</span><br><span class="line">  myObject-&gt;<span class="built_in">TraceConnectWithoutContext</span> (<span class="string">&quot;MyInteger&quot;</span>, <span class="built_in">MakeCallback</span> (IntTrace));</span><br><span class="line">  myObject-&gt;m_myInt = <span class="number">1234</span>;</span><br><span class="line">  myObject-&gt;m_myInt = <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>暂略，具体参考ns-3 tutorial 7.2.6中的一个章节。</p>
<h2 id="实际用例：TCP-cwnd实现"><a href="#实际用例：TCP-cwnd实现" class="headerlink" title="实际用例：TCP-cwnd实现"></a>实际用例：TCP-cwnd实现</h2><p>TCP通过控制发送端cwnd(congestion windows)的大小来规避发送过程中端到端途中网络情况带来的拥塞状况。通过对丢包情况进行侦测，来判断当前是否发生拥塞。如果发生拥塞则减小一次性发送的窗口大小，否则增大窗口大小来提升发送速率。</p>
<h3 id="三个时间片段"><a href="#三个时间片段" class="headerlink" title="三个时间片段"></a>三个时间片段</h3><ol>
<li>Setup Time: It is the period when the main function is running, but before the Simulator::Run is called.</li>
<li>Simulation Time: The period when Simulator::Run is executing.</li>
<li>Teardown Time: The Simulator::Run return control back to the main function, and the allocation of resources get released.</li>
</ol>
<p>一个常见的错误是，在configuration time的时候访问某些在simulation time创建的entities。举个例子，一个sn-3 Socket(套接字，可以查阅传输层相关资料)往往作为动态对象被创建，用于应用程序之间的沟通。<strong>一般来说，ns-3应用不会试图创建一个动态的对象指导StartApplication method被调用。这是为了确保在应用程序试图做某些操作之前，调试的各个方面能够得到充分且完全的确认。</strong></p>
<p>应对上述问题的方法有二：1. 创建一个调试事件，在动态对象创建之后再运行，并且给这个事件挂载上追踪器。2.在configuration time就创建这个动态对象，挂载好，并且把这个对象交给系统以便在simulation time进行使用。</p>
<p>在fifith.cc中，我们创建了一个自己的Myapp class。其中必须要对虚函数StartApplication和StopApplication方法进行重写。它们会在simulation的过程中<strong>按照需要发送消息的时间阶段被自动调用</strong>。</p>
<p>有关ns-3中的应用程序的启动和停止：app.start, app.stop会分别调用app.SetStartTime app.SetStopTime。从\src&#x2F;network&#x2F;model&#x2F;appliaction.cc中可以看到SetStartTime 方法的全部执行内容仅仅是设置了成员变量m_startTime的值(外加一条NS_LOG_FUNCTION(start_time))。(SetStopTime则是m_stopTime)</p>
<p>在ns-3系统中，有一个全局的列表，它记录了所有系统中的节点，<strong>当你在simulation的时候创建了一个节点的时候，就会有一个指向该节点的指针被添加到这个全局的列表，而这个列表的名称就是NodeList，所以你会看到Config Path以&#x2F;NodeList打头。</strong></p>
<p>打开src&#x2F;network&#x2F;model&#x2F;node-list.cc：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">NodeList::Add</span> <span class="params">(Ptr&lt;Node&gt; node)</span></span>&#123;</span><br><span class="line">  <span class="built_in">NS_LOG_FUNCTION</span> (node);</span><br><span class="line">  <span class="keyword">return</span> NodeListPriv::<span class="built_in">Get</span> ()-&gt;<span class="built_in">Add</span> (node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> Ptr&lt;NodeListPriv&gt; <span class="title">NodeListPriv::Get</span> <span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">NS_LOG_FUNCTION_NOARGS</span> ();</span><br><span class="line">  <span class="keyword">return</span> *<span class="built_in">DoGet</span> ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Ptr&lt;NodeListPriv&gt; * <span class="title">NodeListPriv::DoGet</span> <span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="built_in">NS_LOG_FUNCTION_NOARGS</span> ();</span><br><span class="line">  <span class="type">static</span> Ptr&lt;NodeListPriv&gt; ptr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (ptr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ptr = <span class="built_in">CreateObject</span>&lt;NodeListPriv&gt; ();</span><br><span class="line">      Config::<span class="built_in">RegisterRootNamespaceObject</span> (ptr);</span><br><span class="line">      Simulator::<span class="built_in">ScheduleDestroy</span> (&amp;NodeListPriv::Delete);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">NodeListPriv::Add</span> <span class="params">(Ptr&lt;Node&gt; node)</span></span>&#123;</span><br><span class="line">  <span class="built_in">NS_LOG_FUNCTION</span> (<span class="keyword">this</span> &lt;&lt; node);</span><br><span class="line">  <span class="type">uint32_t</span> index = m_nodes.<span class="built_in">size</span> ();</span><br><span class="line">  m_nodes.<span class="built_in">push_back</span> (node);</span><br><span class="line">  Simulator::<span class="built_in">ScheduleWithContext</span> (index, <span class="built_in">TimeStep</span> (<span class="number">0</span>), &amp;Node::Initialize, node);</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，NodeListPriv这个类是NodeList中部分private属性的api的实现。从NodeListPriv的Doget函数可以看出，<strong>只有一个全局的指向一个NodeListPriv的指针</strong>，也就是说只有一个NodeListPriv，而这个可以认为就是NodeList的具体载体。NodeListPriv可以提供大量的api，而NodeList中的public方法都是通过NodeListPriv::Get()获取到这个全局的NodeListPriv指针后调用相应的方法来实现的。因此，<strong>NodeListPriv可以认为是真正的定义NodeList的类，并且具体实例化对象只有一个全局的NodeList，而NodeList类则是对NodeList类Public方法的一个封装聚合。看上去比较类似于C语言中用struct结构体包含一堆相同类型的函数指针一样。</strong></p>
<p>打开src&#x2F;network&#x2F;model&#x2F;application.cc，可以看到如下代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::DoInitialize</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">NS_LOG_FUNCTION</span> (<span class="keyword">this</span>);</span><br><span class="line">  m_startEvent = Simulator::<span class="built_in">Schedule</span> (m_startTime, &amp;Application::StartApplication, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (m_stopTime != <span class="built_in">TimeStep</span> (<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      m_stopEvent = Simulator::<span class="built_in">Schedule</span> (m_stopTime, &amp;Application::StopApplication, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  Object::<span class="built_in">DoInitialize</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是ns3-tutorial的原文，这一段的内容信息量集中且非常关键。</p>
<blockquote>
<p>Here, we finally come to the end of the trail. If you have kept it all straight, when you implement an ns-3 Application, your new application inherits from class Application. You override the StartApplication and StopApplication methods and provide mechanisms for starting and stopping the flow of data out of your new Application. When a Node is created in the simulation, it is added to a global NodeList. The act of adding a node to this NodeList causes a simulator event to be scheduled for time zero which calls the Node::Initialize method of the newly added Node to be called when the simulation starts. Since a Node inherits from Object, this calls the Object::Initialize method on the Node which, in turn, calls the DoInitialize methods on all of the Objects aggregated to the Node (think mobility models). Since the Node Object has overridden DoInitialize, that method is called when the simulation starts. The Node::DoInitialize method calls the Initialize methods of all of the Applications on the node. Since Applications are also Objects, this causes Application::DoInitialize to be called. When Application::DoInitialize is called, it schedules events for the StartApplication and StopApplication calls on the Application. These calls are designed to start and stop the flow of data from the Application</p>
</blockquote>
<p>node创建的时候会被添加到全局列表。当调试开始的时候，node的initialize方法会被调用。Object::initialize与其他很多函数如startapplication这种可以在子类重载实现多态的虚函数不一样，它不是virutal的，而且node中也没有对initialize进行重写，因此调用node::initialize的方法其实调用的就是Object::initialize。<strong>读源码可知，它会调用所有node节点中聚合对象的DoInitialize的方法(有一个遍历的函数)，而application对象就聚合在node中，因此application的DoInitialize也会被调用，而application的DoInitialize会为Start stopapplication安排事件调用，这样就实现了application中信息流的控制。</strong></p>
<p>下面画一个我个人理解的流程图。</p>
<p>Create the node -&gt; the node get registered in the NodeList(注：node不属于我们之前提到的在simulation进行过程中创建的动态对象。node属于网络拓扑图的一部分，这是调试的前提，在调试开始前要先分配好内存空间)</p>
<p>Simulation starts -&gt; node(registered)::initialize -&gt; node.application.Doinitialize -&gt; schedules events for Start&#x2F;Stop application -&gt; the flow of data gets controlled.</p>
<h3 id="sixth-cc"><a href="#sixth-cc" class="headerlink" title="sixth.cc"></a>sixth.cc</h3><p>这个是讲解tracing的一个比较具体的文件。fifth.cc只是个过渡的。ns-3 tutorial有一些我个人不太能接受的点，就是前面提到重要的东西没有在接下来的讲解中马上使用。甚至tutorial自己都承认了(笑)：</p>
<blockquote>
<p>It may have occurred to you that we just spent a lot of time implementing an example that exhibits all of the problems we purport to fix with the ns-3 tracing system! You would be correct. But, bear with us. We’ve not done yet.(看到这句话真的脸上笑嘻嘻，心里mmp)</p>
</blockquote>
<p>我也是挺哭笑不得的。作为新手，而且英语非母语，读完的东西如果不能立即得到讲解对阅读的连贯性的影响应该还是蛮大的。前面提到的Config subsystem用于连接追踪源和追踪调度函数的知识点也没在接下来的sixth.cc使用，还用的是objectbase-&gt;TraceConnect(哭，我都怀疑自己对文档的理解了)</p>
<p>言归正传，咱们可以直接跳过fifth.cc这个官方都承认过渡的文件，把精力放在sixth.cc文件上。</p>
<p>咱们关注CwndChange和RxDrop中，Ptr&lt;OutputStreamWrapper&gt;，Ptr&lt;PcapFileWrapper&gt;。这个stream参数的拷贝函数是private的，这说明了根本就不希望用户来进行对这个对象的拷贝操作。这个对象解决了C++流中很麻烦的问题，相当于是一个安全的黑盒封装。作为初级学习者咱们只需要知道并且调用它就好了。</p>
<p>stream不能被copy，但我们依旧可以创建它。如下sixth.cc片段代码我们可以了解如何创建流并且将流传递给追踪调度函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mian main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  AsciiTraceHelper asciiTraceHelper;</span><br><span class="line">  Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.<span class="built_in">CreateFileStream</span> (<span class="string">&quot;sixth.cwnd&quot;</span>);</span><br><span class="line">  ns3TcpSocket-&gt;<span class="built_in">TraceConnectWithoutContext</span> (<span class="string">&quot;CongestionWindow&quot;</span>, <span class="built_in">MakeBoundCallback</span> (&amp;CwndChange, stream));</span><br><span class="line">    </span><br><span class="line">  PcapHelper pcapHelper;</span><br><span class="line">  Ptr&lt;PcapFileWrapper&gt; file = pcapHelper.<span class="built_in">CreateFile</span> (<span class="string">&quot;sixth.pcap&quot;</span>, std::ios::out, PcapHelper::DLT_PPP);</span><br><span class="line">  devices.<span class="built_in">Get</span> (<span class="number">1</span>)-&gt;<span class="built_in">TraceConnectWithoutContext</span>(<span class="string">&quot;PhyRxDrop&quot;</span>, <span class="built_in">MakeBoundCallback</span> (&amp;RxDrop, file));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PcapFileWrapper是一个复杂的封装，它的父类是ns3::Object。而OutputStreamWrapper本身根本就不是ns-3 Object。</p>
<p>对于PacapFileWrapper构造函数的第三个参数，DLT_PPP用于记录带有point to point headers的包，DLT_EN10MB用于记录csma 设备的包而DLT_IEEE802_11则适用于记录WIFI设备的包。</p>
<p>MakeBoundCallback其中，makeboundcallback可以给callback函数带上必然使用的参数(传入第一个callback指针后，后面是可变长的参数，可以按照需要放入多个)。在这里就可以将创建的Ptr stream, file指针传入callback函数中的第一个参数。</p>
<p>ns-3中主要包含有两个helper: Device helper和protocol helper，device helpers主要聚焦于追踪应当发生于某一节点内部的问题，创建的文件遵循&lt;prefix&gt;-&lt;node&gt;-&lt;device&gt;命名惯例，而device helpers主要聚焦于协议或者配对的接口，关注的是协议栈模型，创建的跟踪文件遵循&lt;prefix&gt;-&lt;protocol&gt;-&lt;interface&gt;的命名惯例。因此，跟踪的方式也存在一下两个维度的分类。</p>
<img src="C:\Users\tang\AppData\Roaming\Typora\typora-user-images\image-20230712152040073.png" alt="image-20230712152040073" style="zoom:67%;" />

<p>PcapHelperForDevice提供了高层的功能。它会调用低层次的enablepcap，enablepcapinternal。</p>
<blockquote>
<p>The class PcapHelperForDevice is a mixin provides the high level functionality for using pcap tracing in an ns-3 device. Every device must implement a single virtual method inherited from this class.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnablePcap</span> <span class="params">(std::string prefix, Ptr&lt;NetDevice&gt; nd, <span class="type">bool</span> promiscuous = <span class="literal">false</span>, <span class="type">bool</span> explicitFilename <span class="type">void</span> EnablePcap (std::string prefix, std::string ndName, <span class="type">bool</span> promiscuous = <span class="literal">false</span>, <span class="type">bool</span> explicitFilename <span class="type">void</span> EnablePcap (std::string prefix, NetDeviceContainer d, <span class="type">bool</span> promiscuous = <span class="literal">false</span>);</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> EnablePcap (std::string prefix, NodeContainer n, <span class="type">bool</span> promiscuous = <span class="literal">false</span>);</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> EnablePcap (std::string prefix, <span class="type">uint32_t</span> nodeid, <span class="type">uint32_t</span> deviceid, <span class="type">bool</span> promiscuous = <span class="literal">false</span>);</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> EnablePcapAll (std::string prefix, <span class="type">bool</span> promiscuous = <span class="literal">false</span>);</span></span></span><br></pre></td></tr></table></figure>



<p>对于EnablePcap函数，有一个promiscuous默认为false的参数，promiscuous mode为混杂模式，也就是接收所有经过它的数据包，而不仅仅只接收发给它的数据包。EnablePcap有多种形式，prefix之后用Ptr&lt;device&gt;，netdevicecontainer，nodecontainer，nodeID等等。当然，也可以直接使用helper.EnablePcapAll(“prefix”)直接打开全部的追踪。</p>
<p>注意，每一个node具有唯一的node id，每一个interface有一个为一个device id。</p>
<p>AsciiTraceHelperForDevice之所以EnableAscii有两倍的重载数量，是因为ns-3支持多个tracing源向同一个文件中写入追踪记录。因此EnableAscii，可以使用Ptr stream来代替prefix。</p>
<p>注意，如果想使用Name进行追踪，可以使用Names::Add(“client”, …)，只是要注意，每一个名称必须只能绑定一个Node。注意，ascii tracing如何要自定义文件名，要带上.tr后缀。</p>
<p>Ptr&lt;OutputStreamWrapper&gt; stream &#x3D; asciiTraceHelper.CreateFileStream (“trace-file-name.tr”);比如说，如果你想用stream来使用EnableAscii的话，在创建streamwrapper对象的时候需要给文件后缀名加上.tr。这个是Ascii tracing才有的，Enablepcap的封装中并不支持直接使用pcapstream直接进行enable。</p>
<h2 id="TraceHelper总结概述"><a href="#TraceHelper总结概述" class="headerlink" title="TraceHelper总结概述"></a>TraceHelper总结概述</h2><p>我们来总结一下traceHelper的结构和具体实现，首先Helper有两大类，Ascii和Pcap，下面只讲解Pcap，Ascii同理(各种类中把TraceHelper中的Pacp换成Ascii就好了，两者小小的不同(是否可通过stream创建在前面也提及了)</p>
<p>首先，helper中简略认为有，PcapHelper，PcapHelperForIpv4，PcapHelperForIpv6，PcapHelperForDevice。</p>
<p>第一个PcapHelper(AsciiTraceHelper)，它可以创建实例对象，这个实例对象可以通过CreateFile，CreateFileStream等函数帮助我们创建记录文件，流等辅助工具。</p>
<p>PcapHelperForDevice(AsciiTraceHelperForDevice)，则是一个提供了用户层面的，提供pcap操作的封装。<strong>它是一个虚基类，因此不可以直接被创建为实例对象，它只负责为子类提供像EnablePcap(最终调用EnablePcapInternal)，EnablePcapInternal这些通用层面的函数。这些函数的调用应当在子类对象中</strong></p>
<p><strong>在point-to-point-helper.h文件中，这个helper类就多继承了PcapHelperForDevice，AsciiTraceHelperForDevice类，因此在代码中就可以通过PointToPointHelper实例化对象调用PcapHelperForDevice提供的EnablePcap函数。</strong>详细调用例子可以参考third.cc文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PointToPointHelper</span> : <span class="keyword">public</span> PcapHelperForDevice, <span class="keyword">public</span> AsciiTraceHelperForDevice&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">&lt;file&gt;.cc:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PointToPointHelper::EnablePcapInternal</span> <span class="params">(std::string prefix, Ptr&lt;NetDevice&gt; nd, <span class="type">bool</span> promiscuous, <span class="type">bool</span> explicitFilename)</span><span class="comment">// override the virtual function.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// All of the Pcap enable functions vector through here including the ones</span></span><br><span class="line">  <span class="comment">// that are wandering through all of devices on perhaps all of the nodes in</span></span><br><span class="line">  <span class="comment">// the system.  We can only deal with devices of type PointToPointNetDevice.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，在InternetStackHelper头文件中，我们也可以看到有如下继承关系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InternetStackHelper</span> : <span class="keyword">public</span> PcapHelperForIpv4, <span class="keyword">public</span> PcapHelperForIpv6, </span><br><span class="line">                            <span class="keyword">public</span> AsciiTraceHelperForIpv4, <span class="keyword">public</span> AsciiTraceHelperForIpv6</span><br></pre></td></tr></table></figure>

<p><strong>这个也就是作为Helper在protocol上封装的一个典范例子。前面PointToPointHelper则是在设备层面上进行封装的一个典范例子。</strong></p>
<h2 id="总结tutorial中提及的tracing的三种层面的方法"><a href="#总结tutorial中提及的tracing的三种层面的方法" class="headerlink" title="总结tutorial中提及的tracing的三种层面的方法"></a>总结tutorial中提及的tracing的三种层面的方法</h2><ol>
<li>object::TraceConnect，最底层，直接对单个对象进行追踪源和追踪器的绑定。</li>
<li>PcapHelper, PcapHelperForIpv4, PcapHelperForDevice，从device和protocol两个层面，封装了文件记录追踪的函数。</li>
<li>Config::Connect，通过Config Path来定位，从更高一层次来对tracing进行实现。</li>
</ol>
<p><strong>可以说，object::TraceConnect是对单个object的层面上进行底层的traceconnect，而DeviceHelper，protocolHelper中的enableascii，enablepcap是从设备，协议层面对trace进行了一层封装，使得通过文件.tr .pcap记录的方式更加的方便。而Config subsystem则从更高层面的系统级对追踪源和追踪器的连接进行了更加高层次的封装。在tutorial中的讲述中，Config subsystem会通过Config path最终找到对应的node object并且使用底层的traceconnect进行连接。不过实际使用中如果不需要高级的功能使用Config::Connect还是会有些麻烦。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://tang-mouren.github.io">Tang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://tang-mouren.github.io/2023/07/14/ns-3-tracing/">https://tang-mouren.github.io/2023/07/14/ns-3-tracing/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/Battlefieldjpg/shocktrooper.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2003/07/07/hello-world/" title="My first blog"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">My first blog</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/Battlefieldjpg/shocktrooper.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Tang</div><div class="author-info__description">Nothing important *´∀`)´∀`)*</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tang-mouren"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#NS-3-Tracing-%E8%8D%89%E7%A8%BF"><span class="toc-number">1.</span> <span class="toc-text">NS-3 Tracing (草稿)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">前言概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E7%94%A8%E7%9A%84%E8%B7%9F%E8%B8%AA%E6%BA%90%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">有哪些可用的跟踪源？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Aconfig-path%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">如何确定config path？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">如何找出回调函数的返回值以及参数类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TraceValue%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">TraceValue又是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%BF%9B%E8%A1%8C%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.6.</span> <span class="toc-text">一个例子进行回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%94%A8%E4%BE%8B%EF%BC%9ATCP-cwnd%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">实际用例：TCP-cwnd实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%97%B6%E9%97%B4%E7%89%87%E6%AE%B5"><span class="toc-number">2.1.</span> <span class="toc-text">三个时间片段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sixth-cc"><span class="toc-number">2.2.</span> <span class="toc-text">sixth.cc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TraceHelper%E6%80%BB%E7%BB%93%E6%A6%82%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">TraceHelper总结概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93tutorial%E4%B8%AD%E6%8F%90%E5%8F%8A%E7%9A%84tracing%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B1%82%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">总结tutorial中提及的tracing的三种层面的方法</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/14/ns-3-tracing/" title="ns-3 tracing">ns-3 tracing</a><time datetime="2023-07-14T07:06:25.000Z" title="Created 2023-07-14 15:06:25">2023-07-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2003/07/07/hello-world/" title="My first blog">My first blog</a><time datetime="2003-07-06T16:00:00.000Z" title="Created 2003-07-07 00:00:00">2003-07-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Tang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>